# Generated by Django 5.2.8 on 2026-01-21 00:00
from django.db import migrations, models
import django.db.models.deletion
from django.db.models import Q


def backfill_schedule_for_existing_attendance(apps, schema_editor):
    Attendance = apps.get_model('attendance', 'Attendance')
    SubjectSchedule = apps.get_model('attendance', 'SubjectSchedule')

    # Attempt to link legacy attendance rows to a schedule based on time_in within window
    # This is best-effort and safe to skip if no matches
    for att in Attendance.objects.filter(schedule__isnull=True).iterator():
        try:
            # Find schedules for subject on that date's weekday or exact date
            day = att.date.weekday()
            # Prefer exact date schedules
            schedules = SubjectSchedule.objects.filter(subject_id=att.subject_id, date=att.date).order_by('time_start')
            if not schedules.exists():
                schedules = SubjectSchedule.objects.filter(subject_id=att.subject_id, day_of_week=day, date__isnull=True).order_by('time_start')
            if not schedules.exists() or not att.time_in:
                continue
            from datetime import timedelta, datetime
            # Use conservative 0-minute tolerance; system settings not accessible here
            for sch in schedules:
                if sch.time_start <= att.time_in <= sch.time_end:
                    att.schedule_id = sch.id
                    att.save(update_fields=['schedule'])
                    break
        except Exception:
            # Ignore linking errors and continue
            pass


def noop_reverse(apps, schema_editor):
    pass


class Migration(migrations.Migration):

    dependencies = [
        ("attendance", "0041_add_enable_timeout_display"),
    ]

    operations = [
        migrations.AddField(
            model_name='attendance',
            name='schedule',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='attendances', to='attendance.subjectschedule'),
        ),
        # Drop old strict per-day constraint
        migrations.RemoveConstraint(
            model_name='attendance',
            name='unique_attendance_per_day',
        ),
        # Add new constraints supporting multiple sessions per day
        migrations.AddConstraint(
            model_name='attendance',
            constraint=models.UniqueConstraint(
                fields=('student', 'subject', 'date', 'schedule'),
                name='unique_attendance_per_day_per_schedule',
            ),
        ),
        migrations.AddConstraint(
            model_name='attendance',
            constraint=models.UniqueConstraint(
                fields=('student', 'subject', 'date'),
                condition=Q(schedule__isnull=True),
                name='unique_attendance_per_day_no_schedule',
            ),
        ),
        migrations.RunPython(backfill_schedule_for_existing_attendance, noop_reverse),
    ]
